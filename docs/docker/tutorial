Dockerfile

什么是Dockerfile
    Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明

e.g: 定制一个nginx镜像(构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件)

FROM nginx
RUN echo '这是一个本地构建的nginx镜像' > /usr/share/nginx/html/index.html

FROM 和 RUN 指令说明：
FROM: 定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx
RUN: 用于执行后面跟着的命令行命令，有以下两种格式

shell 格式:
    RUN <命令行命令>
    # <命令行命令> 等同于，在终端操作的 shell 命令
exec 格式：
    RUN ["可执行文件","参数一","参数二"]
    # 例如：
    # RUN ["./test.php", "dev", "offline"] 等价于 RUN ./test.php dev offline

注意: Dockerfile 的指令每执行一次都会在docker上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：
FROM centos
RUN yum install wget
RUN wget -O redis.tar.gz "http:/download.redis.io/releases/redis-5.0.3.tar.gz"
RUn tar -xvf redis.tar.gz
以上执行会创建 3 层镜像。可简化为以下格式
RUN yum install wget \
    && wget -O redis.tar.gz "http:/download.redis.io/releases/redis-5.0.3.tar.gz" \
    && tar -xvf redis.tar.gz

如上，以 && 符号连接命令，这样执行后，只会创建 1 层镜像


-------------

开始构建镜像
在 Dockerfile 文件的存放目录下，执行构建动作
以下示例，通过目录下的 Dockerfile 构建一个 nginx:test (镜像名称:镜像标签)
注：最后的 . 代表本次执行的上下文路径

docker build -t nginx:test . 

上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件(比如复制),docker build 命令得知这个路径后，会将路径下的所有内容打包
由于 docker 的运行模式是C/S，我们的本机是C, docker 引擎是 S。
实际的构建过程是在docker引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 dcoekr引擎使用

注意： 上下文路径不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢


COPY:
    复制指令，从上下文目录中复制文件或目录到容器里指定路径
    格式：
        COPY [--chown=<user>:<group>] <源路径1>... <目标路径>
        COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]
        [--chown=<user>:<group>]: 可选参考，用户改变复制到容器内文件的拥有者和属组

ADD:
    指令和 COPY 的使用格式一致（同样需求下，官方推荐使用COPY）功能也类似，不同之处如下：
    ADD 的优点：在执行<源文件>为 tar 压缩文件的化，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到<目标路径>
    ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。

CMD:
    类似于 RUN 指令，用于运行程序，但二者运行的时间点不同
    CMD 在 docker run 时运行
    RUN 是在 docker build 时运行
    
    作用：
        为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令参数中指定要运行的程序所覆盖。
    注意：
        如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效
    格式：
        CMD <shell 命令>
        CMD ["<可执行文件或命令>", "<param1>", "<param2>", ...]
        CMD ["<param1", "<param2>", ... ] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
        推荐使用第二种格式，执行过程比较明确。

ENTRYPOINT:
    类似 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。
    但是，如果运行 docker run 是使用了 --entrypoint 选项，次选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。
    优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数
    注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效
    格式：
        ENTRYPOINT ["<executeable", "<param1>", "<param2>"]
    可以搭配 CMD 命令使用: 一般是变参才会使用 CMD， 这里的 CMD 等于是在给 ENTRYPOINT 传参

假设已通过 Dockerfile 构建了 nginx:test 镜像：
    FROM nginx
    ENTRYPOINT ["nginx", "-c"] # 定参
    CMD ["/etc/nginx/nginx.conf"] # 变参

    1. 不传参运行
        docker run nginx:test
    容器内会默认运行一下命令，启动主进程
        nginx -c /etc/nginx/nginx.conf

    2. 传参运行
        docker run nginx:test -c /etc/nginx/new.conf
    容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf: 假设容器内已有此文件)
        nginx -c /etc/nginx/new.conf

ENV:
    设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量
    格式：
        ENV <key> <value>
        ENV <key1>=<value1> <key2>=<value2> ...

    以下示例设置 NODE_VERSION = 7.2.0, 在后续的指令中可以通过 $NODE_VERSION 引用
        ENV NODE_VERSION 7.2.0

        RUN curl -SLO "http://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \
            && curl -SLO "http://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc"
    
ARG:
    构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。
    构建命令 docker build 中可以用 --build-arg <参数名>=<值> 来覆盖
    格式：
        ARG <参数名>[=<默认值>]

VOLUME:
    定义匿名数据卷。在启动容器是忘记挂载数据卷，会自动挂载到匿名卷
    作用:
        避免重要的数据，因容器重启而丢失， 这是非常致命的
        避免容器不断变大
    格式:
        VOLUME ["<路径1>", "<路径2>"]
        VOLUME <路径>
    在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点

EXPOSE:
    仅仅是声明端口
    作用:
        帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射
        在运行时使用端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口
    格式:
        EXPOSE <端口1> [<端口2> ...]

WORKDIR:
    指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。(WORKDIR 指定的工作目录，必须是提前创建好的)
    docker build 构建镜像的过程中的每一个 RUN 命令都是新建一层。只有通过 WORKDIR 创建的目录才会一直存在
    格式：
        WORKDIR <工作目录路径>

USER:
    用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户(用户和用户组必须提前已经存在)
    格式：
        USER <用户名>[:<用户组>]

HEALTHCHECK:
    用于指定某个程序或者指令来监控 docker 容器服务的运行状态
    格式：
        HEALTHCHECK [选项] CMD <命令>: 设置检查容器健康状况的命令
        HEALTHCHECK NONE: 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令

        HEALTHCHECK [选项] CMD <命令> : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法

ONBUILD:
    用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行(假设镜像为 test-build)。
    当有新的 Dockerfile 使用了之前构建的镜像：
    FROM test-build，这时执行新镜像的 Dockerfile 构建的时候，会执行 test-build 的Dockerfile 里的 ONBUILD 指定部分的指令
    格式：
        ONBUILD <其他指令>